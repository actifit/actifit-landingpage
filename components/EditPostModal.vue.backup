<template>
  <div class="modal fade" id="editPostModal" tabindex="-1">
    <div class="modal-dialog modal-lg" role="document">
      <div class="modal-content" v-if="editPost">
        <div class="modal-header">
		  <h5 v-if="editPost.isNewPost" class="modal-title" id="exampleModalLabel">{{ $t('Blog_on_hive') }}</h5>
		  <h5 v-else class="modal-title" id="exampleModalLabel">{{ $t('Editing') }} <a :href="'/'+editPost.author+'/'+editPost.permlink">{{ title }}</a></h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="post-title" style="display: none">{{ $t('Title') }}</label>
            <input class="form-control form-control-lg acti-shadow" :placeholder="$t('Title')" id="post-title" v-model="title" />
          </div>
		  <!-- show permalink if post is edit -->
		  <div v-if="!editPost.isNewPost" class="form-group">
			<a id="post_permlnk" :href="'/'+editPost.author+'/'+editPost.permlink">{{$t('actifit_web_url')}}/{{editPost.permlink}}</a>
		  </div>
          <div class="form-group">
			
			<div class="mavonEditor acti-shadow">
				<no-ssr>

					<!-- :toolbars="markdownOption" -->
				  <mavon-editor language="en" 
								markdown-it-emoji="true" 
								v-model="body" 
								ref="editor"
								@imgAdd="mavonUpImg">
					<!-- Add a custom button after the left toolbar  -->
					  <template slot="left-toolbar-after">
						
						
						<emoji-picker :search="search">
						  <span slot="emoji-invoker" slot-scope="{ events: { click: clickEvent } }" @click.stop="clickEvent">
							<button
							  type="button"
							  class="op-icon far fa-smile"
							  aria-hidden="true"
							  title="Insert Emoji"
							></button>
						  </span>
						  <div slot="emoji-picker" slot-scope="{ emojis }"><!--, selectEmoji-->
							<div class="emoji-picker" :style="{ top: top + 'px', left: left + 'px'}"> <!-- top: display.y + 'px', left: display.x + 'px' } -->
							  <div class="emoji-picker__search">
								<input type="text" v-model="search" v-focus>
							  </div>
							  <div>
								<div v-for="(emojiGroup, category) in emojis" :key="category">
								  <h5>{{ category }}</h5>
								  <div class="emojis">
									<span
									  v-for="(emoji, emojiName) in emojiGroup"
									  :key="emojiName"
									  @click="selectEmoji(emoji)"
									  :title="emojiName"
									>{{ emoji }}</span>
								  </div>
								</div>
							  </div>
							</div>
						  </div>
						</emoji-picker>

						
						
					  </template>
				  </mavon-editor>
				</no-ssr>
			</div>
			
          </div>
		  <!--<div class="form-group">
			<label for="image-upload">{{ $t('Upload_Images') }}</label><br/>
			<input id="image-upload" type="file" v-on:change="uploadImage($event.target.files)" /> 
			<i class="fas fa-spin fa-spinner" v-if="imgUploading"></i>
		  </div>-->
          <div class="form-group">
            <!--<label for="post-tags" style="display: none">{{ $t('Tags') }}</label>
            <input class="form-control form-control-lg acti-shadow" :placeholder="$t('Tags')"/>-->
			<TagInput id="tagItem" ref="tagItem" :initialItems="tags" class="form-control form-control-lg acti-shadow"/>
          </div>
        </div>
		<div class="modal-footer m-2" style="display: none">
			<div class="bchain-option btn col-6 p-2 row text-left mx-auto" v-if="cur_bchain=='HIVE'">
				<input type="radio" id="hive" value="HIVE" v-model="target_bchain">
				<img src="/img/HIVE.png" style="max-height: 50px" v-on:click="target_bchain = 'HIVE'" :class="adjustHiveClass">
				<label for="hive">HIVE ONLY</label>
			</div>
			<div class="bchain-option btn col-6 p-2 row text-left mx-auto" v-else-if="cur_bchain=='STEEM'">
				<input type="radio" id="steem" value="STEEM" v-model="target_bchain">
				<img src="/img/STEEM.png" style="max-height: 50px" v-on:click="target_bchain = 'STEEM'" :class="adjustSteemClass">
				<label for="steem">STEEM ONLY</label>
			</div>
			<div class="bchain-option btn col-6 p-2 row text-left  mx-auto">
				<input type="radio" id="hive_steem" value="BOTH" v-model="target_bchain">
				<img src="/img/HIVE.png" v-on:click="target_bchain = 'BOTH'" style="max-height: 50px" :class="adjustBothClass">
				<img src="/img/STEEM.png" v-on:click="target_bchain = 'BOTH'" style="max-height: 50px" :class="adjustBothClass">
				<label for="hive_steem">HIVE + STEEM</label>
			</div>
		</div>
		<div class="modal-footer">
          <button type="button" class="btn btn-white border border-danger text-red acti-shadow" @click.prevent="save()">
            <i class="fas fa-spin fa-spinner" v-if="loading"></i>
            <i class="fas fa-paper-plane" v-else></i>
            <span v-if="editPost.isNewPost">{{ $t('Publish') }}</span><span v-else>{{ $t('Save') }}</span>
			<img src="/img/HIVE.png" style="max-height: 25px" v-if="target_bchain=='HIVE' || target_bchain=='BOTH'">
			<img src="/img/STEEM.png" style="max-height: 25px" v-if="target_bchain=='STEEM' || target_bchain=='BOTH'">
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
  import marked from 'marked'
  //import InputTag from 'vue-input-tag'
  import { mapGetters } from 'vuex'
  import AWS from 'aws-sdk'
  
	// Import data/twitter.json to reduce size, all.json contains data for
	// all emoji sets.
	import data from "emoji-mart-vue-fast/data/all.json";
	// Import default CSS
	import "emoji-mart-vue-fast/css/emoji-mart.css";
	
	// Vue 2:
	//import { Picker, EmojiIndex } from "emoji-mart-vue-fast";
	
	//import data from '@emoji-mart/data'
	//import { Picker } from 'emoji-mart'
	
	//new Picker({ data })

	
	// Create emoji data index.
	// We can change it (for example, filter by category) before passing to the component.
	let emojiIndex;
	//emojiIndex = new EmojiIndex(data);


	/* handles outside clicks for the picker */
	/* begin */
	import Vue from 'vue';

	Vue.directive('click-outside', {
		bind(el, binding, vnode) {
			var vm = vnode.context;
			var callback = binding.value;

			el.clickOutsideEvent = function (event) {
				if (!(el == event.target || el.contains(event.target))) {
					return callback.call(vm, event);
				}
			};
			document.body.addEventListener('click', el.clickOutsideEvent);
		},
		unbind(el) {
			document.body.removeEventListener('click', el.clickOutsideEvent);
		}
	});
	/* end */
  
  import TagInput from '~/components/TagInput';
  
  const actifit_host = 'https://usermedia.actifit.io/'
  const bucketName = 'actifit';
  
  AWS.config.update({ "accessKeyId": process.env.AWS_ACCESS_KEY_ID, "secretAccessKey": process.env.AWS_SECRET_ACCESS_KEY, "region":"us-east-1"});
  
  import EmojiPicker from 'vue-emoji-picker'


  export default {
    components: {
      //InputTag,
	  //Picker,
	  //VuemojiPicker,
	  EmojiPicker,
	  TagInput
    },
    data () {
      return {
		input: '',
		search: '',
        title: '', // post title
        body: '', // post body
        tags: [], // post tags
		file: '', //image
        loading: false, // loading animation in submit button
		imgUploading: false, // loading animation while image upload in progress
		cur_bchain: 'HIVE', //bchain used to edit/save
		target_bchain: 'HIVE', //bchain to which edits will go
		markdownOption: {
			bold: true,
			// more params
		},
		editorConfig: { // markdown editor for post body
          autofocus: true,
          spellChecker: false,
          previewRender: (body) => {
            return marked(body.replace(/@([\w-]+)(?![\w-])/g,'[$&](https://actifit.io/$&)'))
          },
          forceSync: true,
          status: ['lines', 'words'],
          promptURLs: true
        },
		emojiIndex: emojiIndex,
		emojisOutput: "",
		displayEmojiPicker: false,
		initialClick: false,
		top: 0,
        left: 0,
		searchEnabled: false,
		getSkin: 1,
      }
    },
    computed: {
      ...mapGetters(['editPost', 'bchain']),
	  ...mapGetters('steemconnect', ['user']),
	  ...mapGetters('steemconnect', ['stdLogin']),
	  adjustHiveClass () {
		if (this.target_bchain != 'HIVE'){
			return 'option-opaque';
		}
		return '';
	  },
	  adjustSteemClass () {
		if (this.target_bchain != 'STEEM'){
			return 'option-opaque';
		}
		return '';
	  },
	  adjustBothClass () {
		if (this.target_bchain != 'BOTH'){
			return 'option-opaque';
		}
		return '';
	  },
	  
    },
    watch: {
	  bchain: async function(newBchain) {
		//console.log('profile change in chain '+newBchain);
		this.cur_bchain = newBchain;
		await this.$store.dispatch('steemconnect/refreshUser');
		//this.reload += 1;
	  },
      editPost () {
		console.log('editPost');
        // set initial values after edit button was clicked
        this.title = (this.editPost?this.editPost.title:'')
        this.body = (this.editPost?this.editPost.body:'')
		
		this.tags = [];
		if (this.editPost && !this.editPost.isNewPost){
			const meta = JSON.parse(this.editPost.json_metadata)
			this.tags = meta.hasOwnProperty('tags') ? meta.tags : [] // actifit as default tag, if no tags are present (for some reason)
		}
		//console.log(this.tags);
		//set paste handling script for images
		//this.$el.querySelector('textarea').addEventListener('paste', this.handlePaste);
        // refresh editor
        setTimeout(() => {
          //this.$refs.editor.simplemde.codemirror.refresh()
		  //console.log(this.$refs.editor.textarea.value);
        }, 250)
      }
    },
	directives: {
		focus: {
		  inserted(el) {
			el.focus()
		  },
		},
	},
    methods: {
		handlePaste(event){
			console.log(event);
			const clipboardData = event.clipboardData || window.clipboardData;
			const items = clipboardData.items;
			  
			for (let i = 0; i < items.length; i++) {
				if (items[i].type.indexOf('image') !== -1) {
				  const file = items[i].getAsFile();
				  //this.uploadImage(file);
				  this.uploadImage([file]);
				  break;//only allow one image upload
				}
			}
		},
		/*insert(emoji) {
		  this.input += emoji
		},*/
		selectEmoji(emoji) {
		  /*this.emojisOutput = this.emojisOutput + emoji.native;
		  this.body += emoji.native*/
		  this.emojisOutput = this.emojisOutput + emoji;
		  this.body += emoji;
		  //setMessageToSend(messageToSend + emoji.native)
		},
		async mavonUpImg(pos, file){
		  let url = await this.uploadImage(pos, [file])
		  //$vm = this.$refs.md
		  //this.$refs.editor.$img2Url(pos, url);
		},
		async uploadImage (pos, file) {
		  //display image upload animation
		  this.imgUploading = true;
		  
		  //generate new key/name for the image to store
		  var key = (Date.now().toString(36) + Math.random().toString(36).substr(2, 11) + Math.random().toString(36).substr(2, 11)).toUpperCase();
		  
		  //initialize S3 instance to process the upload
		  const s3 = new AWS.S3()
		  var params = {
			Bucket: bucketName,
			Key: key, // this will be your share url name
			ContentType: 'image/jpeg',
			Body: file[0], 
			ACL: 'public-read' 
		  }
		  
		  let img_orig_name = file[0].name
		  let img_url = actifit_host + key
		  
		  //let txt_editor = this.$refs.editor.simplemde; 
		  let txt_editor = this.$el.querySelector('textarea');
		  
		  //reference to this to be used inside the s3 response method
		  let main_container = this;
		  
		  s3.putObject(params).promise().then(function(data) {
			main_container.$refs.editor.$img2Url(pos, img_url);
		  })
		  
		  return;
		  //Execute the upload process
		  s3.putObject(params, function (err, data) {
			if (err){ 
			  //alert(err) // displaying error message
			  console.log(err);
			  main_container.imgUploading = false;
			  //return '';
			} else {
			  console.log("image successfully uploaded");
			  console.log(data);
			  console.log('File uploaded to ' + img_url);
			  //return img_url;
			  
			  //insert the image markdown within the editor as cursor position
			  
			  /*let pos = txt_editor.codemirror.getCursor();
			  txt_editor.codemirror.setSelection(pos, pos);
			  txt_editor.codemirror.replaceSelection('!['+img_orig_name+']('+img_url+')');*/
			  
			  //below works: for now disable logic to try and use mavon's own logic
			  /*
			  let startPos = txt_editor.selectionStart;
			  let endPos = txt_editor.selectionEnd;
			  let newText = '!['+img_orig_name+']('+img_url+')';
			  console.log(txt_editor.selectionStart)
			  console.log(txt_editor.selectionEnd)
			  txt_editor.setSelectionRange(txt_editor.selectionStart, txt_editor.selectionEnd);
			  //txt_editor.replaceSelection('!['+img_orig_name+']('+img_url+')');
			  txt_editor.value = txt_editor.value.substring(0, startPos) 
					+ newText
					+ txt_editor.value.substring(endPos, txt_editor.value.length);
			  txt_editor.setSelectionRange(startPos, startPos + newText.length);

			  main_container.imgUploading = false;
			  */
			}
			/*
			main_container.$notify({
              group: err ? 'error' : 'success',
              text: err ? main_container.$t('Img_Upload_Fail') : main_container.$t('Img_Upload_Success'),
              position: 'top center'
            })*/
		  });
		},
	  async processTrxFunc(op_name, cstm_params, bchain_option){
		if (!localStorage.getItem('std_login')){
		//if (!this.stdLogin){
			let res = await this.$steemconnect.broadcast([[op_name, cstm_params]]);
			//console.log(res);
			if (res.result.ref_block_num) {
				console.log('success');
				return {success: true, trx: res.result};
			}else{
				//console.log(err);
				return {success: false, trx: null};
			}
		}else{
			let operation = [ 
			   [op_name, cstm_params]
			];
			console.log('broadcasting');
			console.log(operation);
			
			//console.log(this.$steemconnect.accessToken);
			//console.log(this.$store.state.accessToken);
			//grab token
			let accToken = localStorage.getItem('access_token')
			
			let op_json = JSON.stringify(operation)
			
			let cur_bchain = (localStorage.getItem('cur_bchain')?localStorage.getItem('cur_bchain'):'HIVE');
			
			if (bchain_option){
				cur_bchain = bchain_option;
			}
			
			let url = new URL(process.env.actiAppUrl + 'performTrxPost/?user='+this.user.account.name+'&bchain='+cur_bchain);
			
			let reqHeads = new Headers({
			  'Content-Type': 'application/json',
			  'x-acti-token': 'Bearer ' + accToken,
			});
			let res = await fetch(url, {
				method: 'POST',
				headers: reqHeads,
				body: JSON.stringify({'operation': JSON.stringify(operation)})
			});
			let outcome = await res.json();
			console.log(outcome);
			if (outcome.error){
				console.log(outcome.error);
				
				//if this is authority error, means needs to be logged out
				//example "missing required posting authority:Missing Posting Authority"
				let err_msg = outcome.trx.tx.error;
				if (err_msg.includes('missing') && err_msg.includes('authority') && this.cur_bchain == bchain_option){
					//clear entry
					localStorage.removeItem('access_token');
					//this.$store.commit('setStdLoginUser', false);
					this.error_msg = this.$t('session_expired_login_again');
					this.$store.dispatch('steemconnect/logout');
				}
				
				this.$notify({
				  group: 'error',
				  text: err_msg,
				  position: 'top center'
				})
				return {success: false, trx: null};
				//this.$router.push('/login');
			}else{
				return {success: true, trx: outcome.trx};
			}
		}
	  },
	  commentSuccess (err, finalize, bchain) {
		let mainRef = this;
		this.$notify({
		  group: err ? 'error' : 'success',
		  text: err ? mainRef.$t('Save_Error') : mainRef.$t('Save_Success_Chain').replace('_CHAIN_', bchain),
		  position: 'top center'
		})
		
		//let cur_bchain = (localStorage.getItem('cur_bchain')?localStorage.getItem('cur_bchain'):'HIVE');
		//this.$store.commit('setBchain', cur_bchain);
		
		
		//reward the user for a new edit
		if (finalize){
			// stop loading animation and show notification
			this.loading = false
			this.RewardUserEdit();
			// update post in store
			this.$store.dispatch('updatePost', {
			  author: this.editPost.author,
			  permlink: this.editPost.permlink
			})
			
		}
	  },
      async save () {
        this.loading = true // start loading animation
		//only convert to array if not already array
		this.tags = this.$refs.tagItem.items;
		//console.log(this.tags);
		//return;
		if (!Array.isArray(this.tags)){
			if (this.tags.indexOf(',')!==-1){
				//contains commas, treat accordingly
				this.tags = this.tags.split(',');
			}else{
				//rely on spaces instead
				this.tags = this.tags.split(' ');
			}
		}
        // prepare tags
        let meta = (!this.editPost.isNewPost && this.editPost.json_metadata?JSON.parse(this.editPost.json_metadata):{});
        meta.tags = [
          //'actifit',
          ...this.tags
            //.filter(tag => tag !== 'actifit') // remove actifit tag, its the first tag automatically
            .filter(String) // remove empty values
            .map(tag => tag.trim()) // trim leading and trailing whitespaces from tags
        ]
		
		if (this.editPost.isNewPost){
			meta.image = [];
		}
		
		//cleanup images to remove any ones which could have been removed
		for (let i = 0;i < meta.image.length;i++){
			if (!this.body.includes(meta.image[i])){
				//remove this element
				meta.image.splice(i, 1);
				i--;
			}
		}
		
		//fetch any new images to add them as proper thumbnails
		
		//matching our image markdown pattern 
		const regex = /!\[(.*?)\]\((.*?)\)/g;
		
		let markdown_imgs = this.body.match(regex);
		
		if (markdown_imgs != null){
			for (let mimgct = markdown_imgs.length - 1;mimgct >= 0;mimgct--){
				//grab url only
				let img_src_url = markdown_imgs[mimgct].substring(markdown_imgs[mimgct].indexOf('(')+1,markdown_imgs[mimgct].indexOf(')'));
				
				//append at the start if not already part of meta
				if (!meta.image.includes(img_src_url)){
					meta.image.unshift(img_src_url);
				}
			}
		}
		
		//ensure that the app info is actifit specific, for example edited by a different editor
		if (!meta.app){
			meta.app = 'actifit/0.5.0';
		}
		if (!meta.app.includes('actifit')){
			meta.app = 'actifit/0.5.0';
		}
		meta.suppEdit = 'actifit.io';
		
		//append post specific data for new posts
		if (this.editPost.isNewPost){
			//let permlnk = this.title.replaceAll('.','-').replaceAll('  ',' ').replaceAll(' ','-').toLowerCase();
			let permlnk = this.title.replaceAll('  ',' ').replaceAll(' ','-').replaceAll('--','-').replace(/[^a-zA-Z0-9\-]/g, '').toLowerCase();
			console.log(permlnk);
			//return;
			//"actifit-"+this.user.account.name.replace('.','-')+"-"+new Date().toISOString().replace(/-|:|\./g, '').toLowerCase();
			this.editPost.parent_author = '';
			this.editPost.parent_permlink = this.tags[0];
			this.editPost.author = this.user.account.name;
			this.editPost.permlink = permlnk;
			
			//fetch beneficiaries from user selection
			var benef_list = [{ 'account':'actifit.pay', 'weight':500 }];//, { 'account':'actifit', 'weight':500 }
			//let remaining_pct -= 500;
			//console.log('ref_benef');
			//console.log(ref_benef);
			/*if (ref_benef){
				benef_list.push(ref_benef);
			}*/
			
			//user selected to get paid only in AFIT tokens
			/*if (typeof req.body.full_afit_pay!= "undefined" && req.body.full_afit_pay!=""){
				benef_list.push({ 'account':'actifit.funds', 'weight':remaining_pct })//{ 'account':'actifit', 'weight':500 }, 
			}*/
			
			//default value for 50-50 pay
			let percent_sbd = 10000;
			
			//check if user selected a different report pay structure than 50-50 SBD/STEEM pay. Other option would be 100% SP
			/*if (typeof req.body.reportSTEEMPayMode!= "undefined" && req.body.reportSTEEMPayMode!=""){
				if (req.body.reportSTEEMPayMode == 'full_SP_Pay'){
					//only change on default if we have a full SP Pay
					percent_sbd = 0;
				}
			}*/
		}
		console.log(this.stdLogin);
        // save changes
		if (!localStorage.getItem('std_login')){
		//if (!this.stdLogin){
		
			this.$steemconnect.comment(
			  this.editPost.parent_author,
			  this.editPost.parent_permlink,
			  this.editPost.author,
			  this.editPost.permlink,
			  this.title,
			  this.body,
			  meta,
			  (err) => {
				this.commentSuccess(err, true, 'STEEM');
			  }
			)
		}else{
			let cstm_params = {
			  "author": this.editPost.author,
			  "title": this.title,
			  "body": this.body,
			  "parent_author": this.editPost.parent_author,
			  "parent_permlink": this.editPost.parent_permlink,
			  "permlink": this.editPost.permlink,
			  "json_metadata": JSON.stringify(meta)
			};
			
			let res = await this.processTrxFunc('comment', cstm_params, this.cur_bchain);
			
			if (res.success){
				this.commentSuccess(null, (this.target_bchain != 'BOTH'), this.cur_bchain);
			}else{
				this.commentSuccess('error saving', false, this.cur_bchain);
			}
			
			//also send the same post again to the other chain
			let other_chain = this.cur_bchain=='HIVE'?'STEEM':'HIVE';
			if (this.target_bchain == 'BOTH'){
				this.loading = true;
				let res = await this.processTrxFunc('comment', cstm_params, other_chain);
			
				if (res.success){
					this.commentSuccess(null, true, other_chain);
				}else{
					this.commentSuccess('error saving', false, other_chain);
				}
			}
		}
      },
	  async RewardUserEdit () {
		let url = new URL(process.env.actiAppUrl + 'rewardActifitWebEdit/'+this.editPost.author);
		//compile all needed data and send it along the request for processing
		let params = {
			web_edit_token: process.env.webEditToken,
			url: this.editPost.url,
		}
		Object.keys(params).forEach(key => url.searchParams.append(key, params[key]))
		try{
			let res = await fetch(url);
			let outcome = await res.json();
			if (outcome.rewarded){
				// notify the user that he received an additional reward
				this.$notify({
				  group: 'success',
				  text: this.$t('youve_been_rewarded') +outcome.amount + this.$t('reward_for_edit'),
				  position: 'top center'
				})
			}
			console.log(outcome);
		}catch(err){
			console.error(err);
		}
	  }
    },
	async mounted () {
		console.log('edit screen mounted');
		this.cur_bchain = (localStorage.getItem('cur_bchain')?localStorage.getItem('cur_bchain'):'HIVE');
		this.$store.commit('setBchain', this.cur_bchain);
		
	}
  }
</script>
<style>
.v-note-panel{
	min-height: 350px;
	max-height: 500px;
}
.maximized {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9999;
  background-color: white;
  overflow: auto;
}

/* emoji picker styling */
/* Tailwind CSS-styled demo is available here: https://codepen.io/DCzajkowski/pen/Brxvzj */

.wrapper {
  position: relative;
  display: inline-block;
}

.regular-input {
  padding: 0.5rem 1rem;
  border-radius: 3px;
  border: 1px solid #ccc;
  width: 20rem;
  height: 12rem;
  outline: none;
}

.regular-input:focus {
  box-shadow: 0 0 0 3px rgba(66,153,225,.5);
}

.emoji-invoker {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  width: 1.5rem;
  height: 1.5rem;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.2s;
  padding: 0;
  background: transparent;
  border: 0;
}
.emoji-invoker:hover {
  transform: scale(1.1);
}
.emoji-invoker > svg {
  fill: #b1c6d0;
}

.emoji-picker {
  position: absolute;
  z-index: 1;
  font-family: Montserrat;
  border: 1px solid #ccc;
  width: 15rem;
  height: 20rem;
  overflow: scroll;
  padding: 1rem;
  box-sizing: border-box;
  border-radius: 0.5rem;
  background: #fff;
  box-shadow: 1px 1px 8px #c7dbe6;
}
.emoji-picker__search {
  display: flex;
}
.emoji-picker__search > input {
  flex: 1;
  border-radius: 10rem;
  border: 1px solid #ccc;
  padding: 0.5rem 1rem;
  outline: none;
}
.emoji-picker h5 {
  margin-bottom: 0;
  color: #b1b1b1;
  text-transform: uppercase;
  font-size: 0.8rem;
  cursor: default;
}
.emoji-picker .emojis {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
}
.emoji-picker .emojis:after {
  content: "";
  flex: auto;
}
.emoji-picker .emojis span {
  padding: 0.2rem;
  cursor: pointer;
  border-radius: 5px;
}
.emoji-picker .emojis span:hover {
  background: #ececec;
  cursor: pointer;
}
.v-note-wrapper .v-note-op .v-left-item div:has(.op-icon.fa-smile){
	float: left;
}
</style>